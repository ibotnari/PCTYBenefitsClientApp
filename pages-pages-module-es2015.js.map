{"version":3,"sources":["./node_modules/@ngx-pwa/local-storage/__ivy_ngcc__/fesm2015/ngx-pwa-local-storage.js","./src/app/pages/dashboard/dashboard.component.ts","./src/app/pages/dashboard/dashboard.component.html","./src/app/pages/miscellaneous/not-found/not-found.component.ts","./src/app/pages/miscellaneous/not-found/not-found.component.html","./src/app/pages/pages-menu.ts","./src/app/pages/pages-routing.module.ts","./src/app/pages/pages.component.ts","./src/app/pages/pages.module.ts","./src/app/pages/services/employee-pinner.service.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwH;AACpE;AACoD;AACJ;;AAE5D;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;AAC3F,sBAAsB,wEAAkB,EAAE,4CAA4C,4BAA4B,EAAE,4CAA4C;AAChK,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA,sBAAsB,4DAAc;AACpC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAc;AACtC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAc;AACzC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAc;AACzC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAc;AACtC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAQ;AACzD,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,+BAA+B,0DAAG;AAClC,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAQ;AACzD,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,+BAA+B,0DAAG;AAClC;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAQ;AAC1D,mBAAmB,gBAAgB;AACnC,oDAAoD,aAAa;AACjE,sDAAsD;AACtD;AACA;AACA;AACA,+BAA+B,4DAAK;AACpC,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAQ;AAC1D,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,+BAA+B,4DAAK;AACpC,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAQ;AAC1D,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,+BAA+B,4DAAK;AACpC,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAK,IAAI,+DAAQ;AACzB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA,YAAY,gEAAS;AACrB;AACA;AACA,YAAY,0DAAG;AACf;AACA,YAAY,0DAAG,QAAQ,2BAA2B,EAAE;AACpD;AACA;AACA;AACA,mBAAmB,iDAAI;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAQ;AACzD,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAG;AAClC,SAAS;AACT;AACA,QAAQ,4DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAA2E;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAS;AAClC;AACA;AACA,QAAQ,iDAAI;AACZ;AACA,kBAAkB,4DAAK;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wBAAwB;AACxB,wBAAwB,2EAA2E;AACnG;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAS;AACjB;AACA,kBAAkB,4DAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAE,EAAE,gBAAgB;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAS;AACxB;AACA;AACA;AACA,QAAQ,+DAAQ,YAAY,uDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAS;AACnC;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA,gEAAgE,qCAAqC,sDAAe,eAAe,sDAAe,kBAAkB,sDAAe,kBAAkB,sDAAe,eAAe;AACnO,0BAA0B,wEAAkB,EAAE,gDAAgD,8BAA8B,8DAAQ,eAAe,8DAAQ,kBAAkB,8DAAQ,kBAAkB,8DAAQ,eAAe,EAAE,gDAAgD;AAChR;AACA,KAAK,gCAAgC,OAAO,oDAAM,wBAAwB,GAAG;AAC7E,KAAK,gCAAgC,OAAO,oDAAM,2BAA2B,GAAG;AAChF,KAAK,gCAAgC,OAAO,oDAAM,2BAA2B,GAAG;AAChF,KAAK,gCAAgC,OAAO,oDAAM,wBAAwB;AAC1E;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU;AAC/B,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,GAAG;AACnB,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,GAAG;AACnB,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,GAAG;AACnB,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAU;AAC7B;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,gEAAS,CAAC,mDAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY,EAAE,IAAI;AACpC;AACA;AACA,sEAAsE,wCAAwC,sDAAe,aAAa;AAC1I,6BAA6B,wEAAkB,EAAE,mDAAmD,iCAAiC,8DAAQ,aAAa,EAAE,mDAAmD;AAC/M;AACA,KAAK,gCAAgC,OAAO,oDAAM,sBAAsB;AACxE;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU;AAC/B,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAE;AACjB;AACA;AACA,0DAA0D,oCAAoC;AAC9F,uBAAuB,wEAAkB,EAAE,6CAA6C,6BAA6B,EAAE,6CAA6C;AACpK,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,WAAW,EAAE,QAAQ,EAAE;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;AAC3F,sBAAsB,wEAAkB,EAAE,4CAA4C,6BAA6B,8DAAQ,CAAC,yDAAW,GAAG,8DAAQ,aAAa,8DAAQ,eAAe,8DAAQ,kBAAkB,8DAAQ,kBAAkB,8DAAQ,eAAe,EAAE,4CAA4C;AAC/S,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA,oBAAoB,yDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAAQ;AACnE;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA,mBAAmB,+CAAE;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG,QAAQ,wBAAwB,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG,QAAQ,6BAA6B,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB,EAAE;AAC7C,0BAA0B,qBAAqB,EAAE;AACjD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA,SAAS;AACT;AACA;AACA,kDAAkD,8BAA8B,sDAAe,iBAAiB,sDAAe,iBAAiB,sDAAe,aAAa;AAC5K,mBAAmB,wEAAkB,EAAE,yCAAyC,uBAAuB,8DAAQ,iBAAiB,8DAAQ,iBAAiB,8DAAQ,aAAa,EAAE,yCAAyC;AACzN;AACA,KAAK,sBAAsB;AAC3B,KAAK,sBAAsB;AAC3B,KAAK,gCAAgC,OAAO,oDAAM,sBAAsB;AACxE;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,wDAAU;AACxB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,sBAAsB,GAAG,sBAAsB,GAAG;AACjF,sBAAsB,oDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,QAAQ,EAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"pages-pages-module-es2015.js","sourcesContent":["import { ɵɵdefineInjectable, Injectable, InjectionToken, ɵɵinject, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { ReplaySubject, fromEvent, race, throwError, of, Observable, asyncScheduler, from } from 'rxjs';\nimport { mergeMap, map, first, mapTo, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\n\nimport * as ɵngcc0 from '@angular/core';\nclass JSONValidator {\n    /**\n     * Validate a JSON data against a Jsubset of the JSON Schema standard.\n     * Types are enforced to validate everything: each schema must\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema. Must have a `type`.\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/VALIDATION.md}\n     */\n    validate(data, schema) {\n        switch (schema.type) {\n            case 'string':\n                return this.validateString(data, schema);\n            case 'number':\n            case 'integer':\n                return this.validateNumber(data, schema);\n            case 'boolean':\n                return this.validateBoolean(data, schema);\n            case 'array':\n                return this.validateArray(data, schema);\n            case 'object':\n                return this.validateObject(data, schema);\n        }\n    }\n    /**\n     * Validate a string\n     * @param data Data to validate\n     * @param schema Schema describing the string\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateString(data, schema) {\n        if (typeof data !== 'string') {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        if ((schema.maxLength !== undefined) && (data.length > schema.maxLength)) {\n            return false;\n        }\n        if ((schema.minLength !== undefined) && (data.length < schema.minLength)) {\n            return false;\n        }\n        if (schema.pattern) {\n            let regularExpression = null;\n            try {\n                regularExpression = new RegExp(schema.pattern);\n            }\n            catch (_a) { }\n            if (regularExpression && !regularExpression.test(data)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a number or an integer\n     * @param data Data to validate\n     * @param schema Schema describing the number or integer\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateNumber(data, schema) {\n        if (typeof data !== 'number') {\n            return false;\n        }\n        if ((schema.type === 'integer') && !Number.isInteger(data)) {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        /* Test is done this way to not divide by 0 */\n        if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n            return false;\n        }\n        if ((schema.maximum !== undefined) && (data > schema.maximum)) {\n            return false;\n        }\n        if ((schema.exclusiveMaximum !== undefined) && (data >= schema.exclusiveMaximum)) {\n            return false;\n        }\n        if ((schema.minimum !== undefined) && (data < schema.minimum)) {\n            return false;\n        }\n        if ((schema.exclusiveMinimum !== undefined) && (data <= schema.exclusiveMinimum)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate a boolean\n     * @param data Data to validate\n     * @param schema Schema describing the boolean\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateBoolean(data, schema) {\n        if (typeof data !== 'boolean') {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate an array\n     * @param data Data to validate\n     * @param schema Schema describing the array\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateArray(data, schema) {\n        if (!Array.isArray(data)) {\n            return false;\n        }\n        if ((schema.maxItems !== undefined) && (data.length > schema.maxItems)) {\n            return false;\n        }\n        if ((schema.minItems !== undefined) && (data.length < schema.minItems)) {\n            return false;\n        }\n        if (schema.uniqueItems) {\n            /* Create a set to eliminate values with multiple occurences */\n            const dataSet = new Set(data);\n            if (data.length !== dataSet.size) {\n                return false;\n            }\n        }\n        /* Specific test for tuples */\n        if (Array.isArray(schema.items)) {\n            return this.validateTuple(data, schema.items);\n        }\n        /* Validate all the values in array */\n        for (const value of data) {\n            if (!this.validate(value, schema.items)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a tuple (array with fixed length and multiple types)\n     * @param data Data to validate\n     * @param schemas Schemas describing the tuple\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateTuple(data, schemas) {\n        /* Tuples have a fixed length */\n        if (data.length !== schemas.length) {\n            return false;\n        }\n        for (let i = 0; i < schemas.length; i += 1) {\n            if (!this.validate(data[i], schemas[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate an object\n     * @param data Data to validate\n     * @param schema JSON schema describing the object\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateObject(data, schema) {\n        /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n        if ((typeof data !== 'object') || (data === null)) {\n            return false;\n        }\n        /* Check if the object doesn't have more properties than expected\n         * Equivalent of `additionalProperties: false`\n         */\n        if (Object.keys(schema.properties).length < Object.keys(data).length) {\n            return false;\n        }\n        /* Validate required properties */\n        if (schema.required) {\n            for (const requiredProp of schema.required) {\n                if (!data.hasOwnProperty(requiredProp)) {\n                    return false;\n                }\n            }\n        }\n        /* Recursively validate all properties */\n        for (const property in schema.properties) {\n            /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n            if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n                if (!this.validate(data[property], schema.properties[property])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a constant\n     * @param data Data ta validate\n     * @param schema JSON schema describing the constant\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateConst(data, schema) {\n        if (!schema.const) {\n            return true;\n        }\n        return (data === schema.const);\n    }\n    /**\n     * Validate an enum\n     * @param data Data ta validate\n     * @param schema JSON schema describing the enum\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateEnum(data, schema) {\n        if (!schema.enum) {\n            return true;\n        }\n        /* Cast as the data can be of multiple types, and so TypeScript is lost */\n        return (schema.enum.includes(data));\n    }\n}\nJSONValidator.ɵfac = function JSONValidator_Factory(t) { return new (t || JSONValidator)(); };\nJSONValidator.ɵprov = ɵɵdefineInjectable({ factory: function JSONValidator_Factory() { return new JSONValidator(); }, token: JSONValidator, providedIn: \"root\" });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JSONValidator, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], null, null); })();\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nconst LS_PREFIX = new InjectionToken('localStoragePrefix', {\n    providedIn: 'root',\n    factory: () => ''\n});\n/**\n * Default name used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_NAME = 'ngStorage';\n/**\n * Token to provide `indexedDB` database name.\n */\nconst IDB_DB_NAME = new InjectionToken('localStorageIDBDBName', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nconst IDB_DB_VERSION = new InjectionToken('localStorageIDBDBVersion', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\nconst DEFAULT_IDB_STORE_NAME = 'localStorage';\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nconst IDB_STORE_NAME = new InjectionToken('localStorageIDBStoreName', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nconst IDB_NO_WRAP = new InjectionToken('localStorageIDBWrap', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_NO_WRAP\n});\n\n/**\n * Exception message when `indexedDB` is not working\n */\nconst IDB_BROKEN_ERROR = 'indexedDB is not working';\n/**\n * Exception raised when `indexedDB` is not working\n */\nclass IDBBrokenError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = IDB_BROKEN_ERROR;\n    }\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nclass SerializationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = SERIALIZATION_ERROR;\n    }\n}\n\nclass IndexedDBDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param dbName `indexedDB` database name\n     * @param storeName `indexedDB` store name\n     * @param dbVersion `indexedDB` database version\n     * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility\n     */\n    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {\n        /**\n         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n         * even after the connection success event happened\n         */\n        this.database = new ReplaySubject(1);\n        /**\n         * Index used when wrapping value. *For backward compatibility only.*\n         */\n        this.wrapIndex = 'value';\n        this.dbName = dbName;\n        this.storeName = storeName;\n        this.dbVersion = dbVersion;\n        this.noWrap = noWrap;\n        /* Connect to `indexedDB`, with prefix if provided by the user */\n        this.connect();\n    }\n    /**\n     * Information about `indexedDB` connection. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version\n     */\n    get backingStore() {\n        return {\n            database: this.dbName,\n            store: this.storeName,\n            version: this.dbVersion,\n        };\n    }\n    /**\n     * Number of items in our `indexedDB` database and object store\n     */\n    get size() {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request to know the number of items */\n            const request = store.count();\n            /* Return the result */\n            return events.pipe(map(() => request.result));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Gets an item value in our `indexedDB` store\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n     */\n    get(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request the value with the key provided by the user */\n            const request = store.get(key);\n            /* Listen events and return the result */\n            return events.pipe(map(() => {\n                if ((request.result !== undefined) && (request.result !== null)) {\n                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n                    if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&\n                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {\n                        return request.result[this.wrapIndex];\n                    }\n                    else {\n                        /* Cast to the wanted type */\n                        return request.result;\n                    }\n                }\n                /* Return `undefined` if the value is empty */\n                return undefined;\n            }));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Sets an item in our `indexedDB` store\n     * @param key The item's key\n     * @param data The item's value\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n        if (data === undefined) {\n            return this.delete(key);\n        }\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };\n            /* Add if the item is not existing yet, or update otherwise */\n            store.put(dataToStore, key);\n            /* Listen to events and return `undefined` as no value is expected */\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes an item in our `indexedDB` store\n     * @param key The item's key\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete the item in store */\n            store.delete(key);\n            /* Listen to events and return `undefined` as no data is expected here */\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes all items from our `indexedDB` objet store\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete all items in object store */\n            store.clear();\n            /* Listen to events and return `undefined` as no data is expected here */\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Get all the keys in our `indexedDB` store\n     * @returns An RxJS `Observable` iterating on each key\n     */\n    keys() {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(\n        /* `first()` is used as the final operator in other methods to complete the `Observable`\n         * (as it all starts from a `ReplaySubject` which never ends),\n         * but as this method is iterating over multiple values, `first()` **must** be used here */\n        first(), mergeMap((transactionData) => {\n            const { store } = transactionData;\n            /* Open a cursor on the store\n             * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE)\n             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n            const request = ('openKeyCursor' in store) ? store.openKeyCursor() : store.openCursor();\n            /* Listen to success event */\n            const success$ = fromEvent(request, 'success').pipe(\n            /* Stop the `Observable` when the cursor is `null` */\n            takeWhile(() => (request.result !== null)), \n            /* This lib only allows string keys, but user could have added other types of keys from outside\n             * It's OK to cast as the cursor as been tested in the previous operator */\n            map(() => request.result.key.toString()), \n            /* Iterate on the cursor */\n            tap(() => { request.result.continue(); }));\n            /* Listen to error event and if so, throw an error */\n            const error$ = this.listenError(request);\n            /* Choose the first event to occur */\n            return race([success$, error$]);\n        }));\n    }\n    /**\n     * Check if a key exists in our `indexedDB` store\n     * @returns An RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Check if the key exists in the store\n             * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/ Legacy).\n             * In older browsers, the value is checked instead, but it could lead to an exception\n             * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).\n             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n             */\n            const request = ('getKey' in store) ? store.getKey(key) : store.get(key);\n            /* Listen to events and return `true` or `false` */\n            return events.pipe(map(() => (request.result !== undefined) ? true : false));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Connects to `indexedDB` and creates the object store on first time\n     */\n    connect() {\n        let request;\n        /* Connect to `indexedDB`\n         * Will fail in Safari cross-origin iframes\n         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n        try {\n            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n            request = indexedDB.open(this.dbName, this.dbVersion);\n        }\n        catch (_a) {\n            this.database.error(new IDBBrokenError());\n            return;\n        }\n        /* Create store on first connection */\n        this.createStore(request);\n        /* Listen to success and error events */\n        const success$ = fromEvent(request, 'success');\n        const error$ = this.listenError(request);\n        /* Choose the first to occur */\n        race([success$, error$])\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Register the database connection in the `ReplaySubject` for further access */\n                this.database.next(request.result);\n            },\n            error: () => {\n                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n                this.database.error(new IDBBrokenError());\n            },\n        });\n    }\n    /**\n     * Create store on first use of `indexedDB`\n     * @param request `indexedDB` database opening request\n     */\n    createStore(request) {\n        /* Listen to the event fired on first connection */\n        fromEvent(request, 'upgradeneeded')\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Check if the store already exists, to avoid error */\n                if (!request.result.objectStoreNames.contains(this.storeName)) {\n                    /* Create the object store */\n                    request.result.createObjectStore(this.storeName);\n                }\n            }\n        });\n    }\n    /**\n     * Open an `indexedDB` transaction and get our store\n     * @param mode `readonly` or `readwrite`\n     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n     */\n    transaction(mode) {\n        /* From the `indexedDB` connection, open a transaction and get the store */\n        return this.database\n            .pipe(mergeMap((database) => {\n            let transaction;\n            try {\n                transaction = database.transaction([this.storeName], mode);\n            }\n            catch (error) {\n                /* The store could have been deleted from outside */\n                return throwError(error);\n            }\n            /* Get the store from the transaction */\n            const store = transaction.objectStore(this.storeName);\n            /* Listen transaction `complete` and `error` events */\n            const events = this.listenTransactionEvents(transaction);\n            return of({ store, events });\n        }));\n    }\n    /**\n     * Listen errors on a transaction or request, and throw if trigerred\n     * @param transactionOrRequest `indexedDb` transaction or request to listen\n     * @returns An `Observable` listening to errors\n     */\n    listenError(transactionOrRequest) {\n        return fromEvent(transactionOrRequest, 'error').pipe(\n        /* Throw on error to be able to catch errors in RxJS way.\n         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n         * if we are on the request and the error is only triggered later by the transaction */\n        mergeMap((event) => throwError(event.target.error)));\n    }\n    /**\n     * Listen transaction `complete` and `error` events\n     * @param transaction Transaction to listen\n     * @returns An `Observable` listening to transaction `complete` and `error` events\n     */\n    listenTransactionEvents(transaction) {\n        /* Listen to the `complete` event */\n        const complete$ = fromEvent(transaction, 'complete');\n        /* Listen to the `error` event */\n        const error$ = this.listenError(transaction);\n        /* Choose the first event to occur */\n        return race([complete$, error$]);\n    }\n}\nIndexedDBDatabase.ɵfac = function IndexedDBDatabase_Factory(t) { return new (t || IndexedDBDatabase)(ɵngcc0.ɵɵinject(IDB_DB_NAME), ɵngcc0.ɵɵinject(IDB_STORE_NAME), ɵngcc0.ɵɵinject(IDB_DB_VERSION), ɵngcc0.ɵɵinject(IDB_NO_WRAP)); };\nIndexedDBDatabase.ɵprov = ɵɵdefineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(ɵɵinject(IDB_DB_NAME), ɵɵinject(IDB_STORE_NAME), ɵɵinject(IDB_DB_VERSION), ɵɵinject(IDB_NO_WRAP)); }, token: IndexedDBDatabase, providedIn: \"root\" });\nIndexedDBDatabase.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [IDB_DB_NAME,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [IDB_STORE_NAME,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [IDB_DB_VERSION,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [IDB_NO_WRAP,] }] }\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IndexedDBDatabase, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [IDB_DB_NAME]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [IDB_STORE_NAME]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [IDB_DB_VERSION]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [IDB_NO_WRAP]\n            }] }]; }, null); })();\n\nclass LocalStorageDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(prefix = '') {\n        /* Prefix if asked, or no prefix otherwise */\n        this.prefix = prefix || '';\n    }\n    /**\n     * Number of items in `localStorage`\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(localStorage.length);\n    }\n    /**\n     * Gets an item value in `localStorage`\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        /* Get raw data */\n        const unparsedData = localStorage.getItem(this.prefixKey(key));\n        let parsedData;\n        /* No need to parse if data is `null` or `undefined` */\n        if ((unparsedData !== undefined) && (unparsedData !== null)) {\n            /* Try to parse */\n            try {\n                parsedData = JSON.parse(unparsedData);\n            }\n            catch (error) {\n                return throwError(error);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(parsedData);\n    }\n    /**\n     * Store an item in `localStorage`\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        let serializedData = null;\n        /* Check if data can be serialized */\n        const dataPrototype = Object.getPrototypeOf(data);\n        if ((typeof data === 'object') && (data !== null) && !Array.isArray(data) &&\n            !((dataPrototype === Object.prototype) || (dataPrototype === null))) {\n            return throwError(new SerializationError());\n        }\n        /* Try to stringify (can fail on circular references) */\n        try {\n            serializedData = JSON.stringify(data);\n        }\n        catch (error) {\n            return throwError(error);\n        }\n        /* Can fail if storage quota is exceeded */\n        try {\n            localStorage.setItem(this.prefixKey(key), serializedData);\n        }\n        catch (error) {\n            return throwError(error);\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        localStorage.removeItem(this.prefixKey(key));\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in `localStorage`\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        localStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in `localStorage`\n     * Note the order of the keys may be inconsistent in Firefox\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return new Observable((subscriber) => {\n            /* Iteretate over all the indexes */\n            for (let index = 0; index < localStorage.length; index += 1) {\n                /* Cast as we are sure in this case the key is not `null` */\n                subscriber.next(this.getUnprefixedKey(index));\n            }\n            subscriber.complete();\n        }).pipe(\n        /* Required to work like other databases which are asynchronous */\n        observeOn(asyncScheduler));\n    }\n    /**\n     * Check if a key exists in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Itérate over all indexes in storage */\n        for (let index = 0; index < localStorage.length; index += 1) {\n            if (key === this.getUnprefixedKey(index)) {\n                /* Wrap in a RxJS `Observable` to be consistent with other storages */\n                return of(true);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(false);\n    }\n    /**\n     * Get an unprefixed key\n     * @param index Index of the key\n     * @returns The unprefixed key name if exists, `null` otherwise\n     */\n    getUnprefixedKey(index) {\n        /* Get the key in storage: may have a prefix */\n        const prefixedKey = localStorage.key(index);\n        if (prefixedKey !== null) {\n            /* If no prefix, the key is already good, otherwrite strip the prefix */\n            return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);\n        }\n        return null;\n    }\n    /**\n     * Add the prefix to a key\n     * @param key The key name\n     * @returns The prefixed key name\n     */\n    prefixKey(key) {\n        return `${this.prefix}${key}`;\n    }\n}\nLocalStorageDatabase.ɵfac = function LocalStorageDatabase_Factory(t) { return new (t || LocalStorageDatabase)(ɵngcc0.ɵɵinject(LS_PREFIX)); };\nLocalStorageDatabase.ɵprov = ɵɵdefineInjectable({ factory: function LocalStorageDatabase_Factory() { return new LocalStorageDatabase(ɵɵinject(LS_PREFIX)); }, token: LocalStorageDatabase, providedIn: \"root\" });\nLocalStorageDatabase.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [LS_PREFIX,] }] }\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalStorageDatabase, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [LS_PREFIX]\n            }] }]; }, null); })();\n\nclass MemoryDatabase {\n    constructor() {\n        /**\n         * Memory storage\n         */\n        this.memoryStorage = new Map();\n    }\n    /**\n     * Number of items in memory\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.size);\n    }\n    /**\n     * Gets an item value in memory\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        const rawData = this.memoryStorage.get(key);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(rawData);\n    }\n    /**\n     * Sets an item in memory\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        this.memoryStorage.set(key, data);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in memory\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        this.memoryStorage.delete(key);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in memory\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        this.memoryStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in memory\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return from(this.memoryStorage.keys());\n    }\n    /**\n     * Check if a key exists in memory\n     * @param key Key name\n     * @returns a RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.has(key));\n    }\n}\nMemoryDatabase.ɵfac = function MemoryDatabase_Factory(t) { return new (t || MemoryDatabase)(); };\nMemoryDatabase.ɵprov = ɵɵdefineInjectable({ factory: function MemoryDatabase_Factory() { return new MemoryDatabase(); }, token: MemoryDatabase, providedIn: \"root\" });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MemoryDatabase, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return []; }, null); })();\n\n/**\n * Factory to create a storage according to browser support\n * @param platformId Context about the platform (`browser`, `server`...)\n * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain\n * @param IDBDBName `indexedDB` database name\n * @param IDBstoreName `indexedDB` storeName name\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/BROWSERS_SUPPORT.md}\n */\nfunction localDatabaseFactory(platformId, LSPrefix, IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap) {\n    /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n     * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n     * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n     */\n    try {\n        // Do not explicit `window` here, as the global object is not the same in web workers\n        if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && ('open' in indexedDB)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - if `indexedDB` exists (issue: IE9)\n            * - it could exist but be `undefined` or `null` (issue: IE private mode)\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - IE10+ and all other browsers in normal mode\n            * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n            return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);\n        }\n        else if (isPlatformBrowser(platformId)\n            && (localStorage !== undefined) && (localStorage !== null) && ('getItem' in localStorage)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - if `localStorage` exists (to be sure)\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - IE9\n            * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n            * - IE / Firefox private mode, but in this case, data will be swiped when the user leaves the app\n            * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n            */\n            return new LocalStorageDatabase(LSPrefix);\n        }\n    }\n    catch (_a) { }\n    /* Will be the case for:\n     * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n     * - Server-side rendering\n     * - All other non-browser context\n     */\n    return new MemoryDatabase();\n}\nclass LocalDatabase {\n}\nLocalDatabase.ɵfac = function LocalDatabase_Factory(t) { return new (t || LocalDatabase)(); };\nLocalDatabase.ɵprov = ɵɵdefineInjectable({ factory: function LocalDatabase_Factory() { return localDatabaseFactory(ɵɵinject(PLATFORM_ID), ɵɵinject(LS_PREFIX), ɵɵinject(IDB_DB_NAME), ɵɵinject(IDB_STORE_NAME), ɵɵinject(IDB_DB_VERSION), ɵɵinject(IDB_NO_WRAP)); }, token: LocalDatabase, providedIn: \"root\" });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalDatabase, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root',\n                useFactory: localDatabaseFactory,\n                deps: [\n                    PLATFORM_ID,\n                    LS_PREFIX,\n                    IDB_DB_NAME,\n                    IDB_STORE_NAME,\n                    IDB_DB_VERSION,\n                    IDB_NO_WRAP,\n                ]\n            }]\n    }], null, null); })();\n\n/**\n * Exception message when a value is not valid against the JSON schema\n */\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nclass ValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = VALIDATION_ERROR;\n    }\n}\n\nclass StorageMap {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param database Storage to use\n     * @param jsonValidator Validator service\n     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {\n        this.database = database;\n        this.jsonValidator = jsonValidator;\n        this.LSPrefix = LSPrefix;\n        this.notifiers = new Map();\n    }\n    /**\n     * **Number of items** in storage, wrapped in an `Observable`.\n     *\n     * @example\n     * this.storageMap.size.subscribe((size) => {\n     *   console.log(size);\n     * });\n     */\n    get size() {\n        return this.database.size\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.size));\n    }\n    /**\n     * Tells you which storage engine is used. *Only useful for interoperability.*\n     * Note that due to some browsers issues in some special contexts\n     * (Firefox private mode and Safari cross-origin iframes),\n     * **this information may be wrong at initialization,**\n     * as the storage could fallback from `indexedDB` to `localStorage`\n     * only after a first read or write operation.\n     * @returns Storage engine used\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {}\n     */\n    get backingEngine() {\n        if (this.database instanceof IndexedDBDatabase) {\n            return 'indexedDB';\n        }\n        else if (this.database instanceof LocalStorageDatabase) {\n            return 'localStorage';\n        }\n        else if (this.database instanceof MemoryDatabase) {\n            return 'memory';\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    /**\n     * Info about `indexedDB` database. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version.\n     * **Values will be empty if the storage is not `indexedDB`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {\n     *   const { database, store, version } = this.storageMap.backingStore;\n     * }\n     */\n    get backingStore() {\n        return (this.database instanceof IndexedDBDatabase) ?\n            this.database.backingStore :\n            { database: '', store: '', version: 0 };\n    }\n    /**\n     * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n     * @returns `localStorage` prefix.\n     * **Values will be empty if the storage is not `localStorage`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'localStorage') {\n     *   const { prefix } = this.storageMap.fallbackBackingStore;\n     * }\n     */\n    get fallbackBackingStore() {\n        return (this.database instanceof LocalStorageDatabase) ?\n            { prefix: this.database.prefix } :\n            { prefix: '' };\n    }\n    get(key, schema) {\n        /* Get the data in storage */\n        return this.database.get(key).pipe(\n        /* Check if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {\n            /* No need to validate if the data is empty */\n            if ((data === undefined) || (data === null)) {\n                return of(undefined);\n            }\n            else if (schema) {\n                /* Validate data against a JSON schema if provided */\n                if (!this.jsonValidator.validate(data, schema)) {\n                    return throwError(new ValidationError());\n                }\n                /* Data have been checked, so it's OK to cast */\n                return of(data);\n            }\n            /* Cast to unknown as the data wasn't checked */\n            return of(data);\n        }));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.set('key', 'value').subscribe(() => {});\n     */\n    set(key, data, schema) {\n        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n         * so removing item instead for all storages to have a consistent API */\n        if ((data === undefined) || (data === null)) {\n            return this.delete(key);\n        }\n        /* Validate data against a JSON schema if provided */\n        if (schema && !this.jsonValidator.validate(data, schema)) {\n            return throwError(new ValidationError());\n        }\n        return this.database.set(key, data).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.set(key, data)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, data); }));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.delete('key').subscribe(() => {});\n     */\n    delete(key) {\n        return this.database.delete(key).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.delete(key)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, undefined); }));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.clear().subscribe(() => {});\n     */\n    clear() {\n        return this.database.clear().pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.clear()), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => {\n            for (const key of this.notifiers.keys()) {\n                this.notify(key, undefined);\n            }\n        }));\n    }\n    /**\n     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n     * * if there is no key, the `next` callback will not be invoked,\n     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n     * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n     * @returns A list of the keys wrapped in a RxJS `Observable`\n     *\n     * @example\n     * this.storageMap.keys().subscribe({\n     *   next: (key) => { console.log(key); },\n     *   complete: () => { console.log('Done'); },\n     * });\n     */\n    keys() {\n        return this.database.keys()\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.keys()));\n    }\n    /**\n     * Tells if a key exists in storage\n     * @returns A RxJS `Observable` telling if the key exists\n     *\n     * @example\n     * this.storageMap.has('key').subscribe((hasKey) => {\n     *   if (hasKey) {}\n     * });\n     */\n    has(key) {\n        return this.database.has(key)\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.has(key)));\n    }\n    watch(key, schema) {\n        /* Check if there is already a notifier and cast according to schema */\n        let notifier = this.notifiers.get(key);\n        if (!notifier) {\n            /* Create a notifier and cast according to schema */\n            notifier = new ReplaySubject(1);\n            /* Memorize the notifier */\n            this.notifiers.set(key, notifier);\n            /* Get the current item value */\n            this.get(key, schema).subscribe({\n                next: (result) => notifier.next(result),\n                error: (error) => notifier.error(error),\n            });\n        }\n        /* Only the public API of the `Observable` should be returned */\n        return notifier.asObservable();\n    }\n    /**\n     * Notify when a value changes\n     * @param key The item's key\n     * @param data The new value\n     */\n    notify(key, value) {\n        const notifier = this.notifiers.get(key);\n        if (notifier) {\n            notifier.next(value);\n        }\n    }\n    /**\n     * RxJS operator to catch if `indexedDB` is broken\n     * @param operationCallback Callback with the operation to redo\n     */\n    catchIDBBroken(operationCallback) {\n        return catchError((error) => {\n            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n            if ((error !== undefined) && (error !== null) && (error.message === IDB_BROKEN_ERROR)) {\n                /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n                 * just trying to check `localStorage` variable causes a security exception.\n                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n                 */\n                try {\n                    if ('getItem' in localStorage) {\n                        /* Fallback to `localStorage` if available */\n                        this.database = new LocalStorageDatabase(this.LSPrefix);\n                    }\n                    else {\n                        /* Fallback to memory storage otherwise */\n                        this.database = new MemoryDatabase();\n                    }\n                }\n                catch (_a) {\n                    /* Fallback to memory storage otherwise */\n                    this.database = new MemoryDatabase();\n                }\n                /* Redo the operation */\n                return operationCallback();\n            }\n            else {\n                /* Otherwise, rethrow the error */\n                return throwError(error);\n            }\n        });\n    }\n}\nStorageMap.ɵfac = function StorageMap_Factory(t) { return new (t || StorageMap)(ɵngcc0.ɵɵinject(LocalDatabase), ɵngcc0.ɵɵinject(JSONValidator), ɵngcc0.ɵɵinject(LS_PREFIX)); };\nStorageMap.ɵprov = ɵɵdefineInjectable({ factory: function StorageMap_Factory() { return new StorageMap(ɵɵinject(LocalDatabase), ɵɵinject(JSONValidator), ɵɵinject(LS_PREFIX)); }, token: StorageMap, providedIn: \"root\" });\nStorageMap.ctorParameters = () => [\n    { type: LocalDatabase },\n    { type: JSONValidator },\n    { type: undefined, decorators: [{ type: Inject, args: [LS_PREFIX,] }] }\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StorageMap, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: LocalDatabase }, { type: JSONValidator }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [LS_PREFIX]\n            }] }]; }, null); })();\n\nclass LocalStorage {\n    /* Use the `StorageMap` service to avoid code duplication */\n    constructor(storageMap) {\n        this.storageMap = storageMap;\n    }\n    /**\n     * Number of items in storage wrapped in an `Observable`\n     *\n     * @example\n     * this.localStorage.length.subscribe((length) => {\n     *   console.log(length);\n     * });\n     */\n    get length() {\n        return this.storageMap.size;\n    }\n    getItem(key, schema) {\n        if (schema) {\n            /* Backward compatibility with version <= 7 */\n            const schemaFinal = ('schema' in schema) ? schema.schema : schema;\n            return this.storageMap.get(key, schemaFinal).pipe(\n            /* Transform `undefined` into `null` to align with `localStorage` API */\n            map((value) => (value !== undefined) ? value : null));\n        }\n        else {\n            return this.storageMap.get(key).pipe(\n            /* Transform `undefined` into `null` to align with `localStorage` API */\n            map((value) => (value !== undefined) ? value : null));\n        }\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.set('key', 'value').subscribe(() => {});\n     */\n    setItem(key, data, schema) {\n        return this.storageMap.set(key, data, schema).pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        mapTo(true));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.delete('key').subscribe(() => {});\n     */\n    removeItem(key) {\n        return this.storageMap.delete(key).pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        mapTo(true));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.clear().subscribe(() => {});\n     */\n    clear() {\n        return this.storageMap.clear().pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        mapTo(true));\n    }\n}\nLocalStorage.ɵfac = function LocalStorage_Factory(t) { return new (t || LocalStorage)(ɵngcc0.ɵɵinject(StorageMap)); };\nLocalStorage.ɵprov = ɵɵdefineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(ɵɵinject(StorageMap)); }, token: LocalStorage, providedIn: \"root\" });\nLocalStorage.ctorParameters = () => [\n    { type: StorageMap }\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalStorage, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: StorageMap }]; }, null); })();\n\n/**\n * This module does not contain anything, it's only useful to provide options via `.forRoot()`.\n */\nclass StorageModule {\n    /**\n     * Only useful to provide options, otherwise it does nothing.\n     * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n     *\n     * @example\n     * NgModule({\n     *   imports: [StorageModule.forRoot({\n     *     LSPrefix: 'custom_',\n     *   })]\n     * })\n     * export class AppModule\n     */\n    static forRoot(config) {\n        return {\n            ngModule: StorageModule,\n            providers: [\n                config.LSPrefix ? { provide: LS_PREFIX, useValue: config.LSPrefix } : [],\n                config.IDBDBName ? { provide: IDB_DB_NAME, useValue: config.IDBDBName } : [],\n                config.IDBStoreName ? { provide: IDB_STORE_NAME, useValue: config.IDBStoreName } : [],\n                config.IDBDBVersion ? { provide: IDB_DB_VERSION, useValue: config.IDBDBVersion } : [],\n                (config.IDBNoWrap === false) ? { provide: IDB_NO_WRAP, useValue: config.IDBNoWrap } : [],\n            ],\n        };\n    }\n}\nStorageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StorageModule });\nStorageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function StorageModule_Factory(t) { return new (t || StorageModule)(); } });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StorageModule, [{\n        type: NgModule\n    }], null, null); })();\n\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JSONValidator, LocalDatabase, LocalStorage, SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError, localDatabaseFactory as ɵa, LS_PREFIX as ɵb, IDB_DB_NAME as ɵc, IDB_DB_VERSION as ɵd, IDB_STORE_NAME as ɵe, IDB_NO_WRAP as ɵf };\n\n//# sourceMappingURL=ngx-pwa-local-storage.js.map","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'ngx-dashboard',\n  templateUrl: './dashboard.component.html',\n  styleUrls: ['./dashboard.component.scss'],\n})\nexport class DashboardComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<nb-card>\n  <nb-card-header>\n    Dashboard Components\n  </nb-card-header>\n\n  <nb-card-body>\n    <nb-card>\n      <nb-card-header>\n        Card 1\n      </nb-card-header>\n\n      <nb-card-body>\n        ........................\n      </nb-card-body>\n    </nb-card>\n    <nb-card>\n      <nb-card-header>\n        Card 2\n      </nb-card-header>\n\n      <nb-card-body>\n        ........................\n      </nb-card-body>\n    </nb-card>\n  </nb-card-body>\n</nb-card>\n","import { NbMenuService } from '@nebular/theme';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-not-found',\n  styleUrls: ['./not-found.component.scss'],\n  templateUrl: './not-found.component.html',\n})\nexport class NotFoundComponent {\n\n  constructor(private menuService: NbMenuService) {\n  }\n\n  goToHome() {\n    this.menuService.navigateHome();\n  }\n}\n","<div class=\"row\">\n  <div class=\"col-md-12\">\n    <nb-card>\n      <nb-card-body>\n        <div class=\"flex-centered col-xl-4 col-lg-6 col-md-8 col-sm-12\">\n          <h2 class=\"title\">404 Page Not Found</h2>\n          <small class=\"sub-title\">The page you were looking for doesn't exist</small>\n          <button nbButton matRipple fullWidth (click)=\"goToHome()\" type=\"button\" class=\"home-button\">\n            Take me home\n          </button>\n        </div>\n      </nb-card-body>\n    </nb-card>\n  </div>\n</div>\n","import { NbMenuItem } from '@nebular/theme';\n\nexport let PINNED_EMPLOYEES_MENU_ITEMS: NbMenuItem = {\n  title: 'PINNED',\n  expanded: true,\n};\nexport const MENU_ITEMS: NbMenuItem[] = [\n  {\n    title: 'Dashboard',\n    icon: 'home-outline',\n    link: '/pages/dashboard',\n    home: true,\n  },\n  {\n    title: 'ADMIN',\n    group: true,\n  },\n  {\n    title: 'Employees',\n    icon: 'people-outline',\n    link: '/pages/employees',\n    home: true,\n    children: null,\n  },\n  {\n    title: 'Benefits',\n    icon: 'award-outline',\n    link: '/pages/benefits',\n    home: true,\n  },\n  {\n    title: 'Discounts',\n    icon: 'gift-outline',\n    link: '/pages/discounts',\n    home: true,\n  },\n  PINNED_EMPLOYEES_MENU_ITEMS,\n];\n\n","import { RouterModule, Routes } from '@angular/router';\nimport { NgModule } from '@angular/core';\n\nimport { PagesComponent } from './pages.component';\nimport { EmployeesComponent } from './employees/employees.component';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { NotFoundComponent } from './miscellaneous/not-found/not-found.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: PagesComponent,\n  children: [\n    {\n      path: '',\n      loadChildren: () => import('./employees/employees.module')\n        .then(m => m.EmployeesModule),\n    },\n    {\n      path: 'dashboard',\n      component: DashboardComponent,\n    },\n    {\n      path: 'employees',\n      loadChildren: () => import('./employees/employees.module')\n        .then(m => m.EmployeesModule),\n    },\n    {\n      path: '**',\n      component: NotFoundComponent,\n    },\n  ],\n}];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class PagesRoutingModule {\n}\n","import { Component, OnInit } from '@angular/core';\nimport { EmployeePinService } from './services/employee-pinner.service';\nimport { Client, Employee } from \"@api/api\";\nimport { MENU_ITEMS, PINNED_EMPLOYEES_MENU_ITEMS } from './pages-menu';\nimport { NbMenuItem } from '@nebular/theme';\n\n@Component({\n  selector: 'ngx-pages',\n  styleUrls: ['pages.component.scss'],\n  template: `\n    <ngx-one-column-layout>\n      <nb-menu [items]=\"menu\"></nb-menu>\n      <router-outlet></router-outlet>\n    </ngx-one-column-layout>\n  `,\n})\nexport class PagesComponent implements OnInit {\n  menu = MENU_ITEMS;\n  constructor(private employeePinService: EmployeePinService) {\n    this.employeePinService.employeePinAddEvent.subscribe({\n      next: (_) => {\n        this.loadEmployeeMenu();\n      },\n    });\n    this.employeePinService.employeePinRemoveEvent.subscribe({\n      next: (_) => {\n        this.loadEmployeeMenu();\n      },\n    });\n  }\n  ngOnInit(): void {\n    this.loadEmployeeMenu();\n  }\n  loadEmployeeMenu() {\n    let menuItems = this.employeePinService.getPinnedEmployees().map(item => this.createMenuItem(item));\n    if (menuItems.length === 0) {\n      menuItems = null;\n    }\n    PINNED_EMPLOYEES_MENU_ITEMS.hidden = (menuItems == null);\n    PINNED_EMPLOYEES_MENU_ITEMS.children = menuItems;\n    this.menu = MENU_ITEMS;\n  }\n  createMenuItem(e: Employee) {\n    return {\n      title: e.firstName + ' ' + e.lastName,\n      icon: 'person-outline',\n      link: '/pages/employees/employee/' + e.id,\n    };\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { NbMenuModule } from '@nebular/theme';\n\nimport { ThemeModule } from '../@theme/theme.module';\nimport { PagesComponent } from './pages.component';\nimport { PagesRoutingModule } from './pages-routing.module';\nimport { NotFoundComponent } from './miscellaneous/not-found/not-found.component';\n\nimport { NbCardModule, NbIconModule, NbInputModule, NbTreeGridModule, NbButtonModule } from '@nebular/theme';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { FormsModule } from \"@angular/forms\";\nimport { EmployeePinService } from \"./services/employee-pinner.service\";\n\n@NgModule({\n  imports: [\n    PagesRoutingModule,\n    ThemeModule,\n    NbMenuModule,\n    NbCardModule,\n    NbIconModule,\n    NbInputModule,\n    NbButtonModule,\n    NbTreeGridModule,\n    FormsModule,\n  ],\n  declarations: [\n    PagesComponent, NotFoundComponent, DashboardComponent,\n  ],\n  providers: [\n    EmployeePinService,\n  ],\n})\nexport class PagesModule {\n}\n","import { Injectable, OnInit, OnDestroy, EventEmitter } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { Employee } from '@api/api';\nimport { StorageMap } from '@ngx-pwa/local-storage';\n\n@Injectable()\nexport class EmployeePinService implements OnInit, OnDestroy {\n  private STORAGE_KEY: string = 'EmployeePinService:pinnedEmployees';\n  private pinnedEmployees: Set<Employee> = new Set<Employee>();\n  employeePinAddEvent: EventEmitter<Employee> = new EventEmitter<Employee>();\n  employeePinRemoveEvent: EventEmitter<Employee> = new EventEmitter<Employee>();\n\n  constructor(private storage: StorageMap) {\n    this.storage.get(this.STORAGE_KEY).subscribe((storedPinnedEmployees: Set<Employee>) => {\n      if (!(storedPinnedEmployees === undefined)) {\n        this.pinnedEmployees = storedPinnedEmployees;\n      }\n    });\n  }\n\n  ngOnInit(): void {\n  }\n  pinEmployee(employee: Employee) {\n    if (!this.isPinned(employee)) {\n      this.pinnedEmployees.add(employee);\n    }\n    this.employeePinAddEvent.emit(employee);\n  }\n  unpinEmployee(employee: Employee) {\n    for (const pinnedEmployee of this.pinnedEmployees) {\n      if (pinnedEmployee.id === employee.id) {\n        this.pinnedEmployees.delete(pinnedEmployee);\n        break;\n      }\n    }\n    // this.pinnedEmployees.delete(employee);\n    this.employeePinRemoveEvent.emit(employee);\n  }\n  getPinnedEmployees() {\n    return Array.from(this.pinnedEmployees.keys());\n  }\n  isPinned(employee: Employee) {\n    for (const pinnedEmployee of this.pinnedEmployees) {\n      if (pinnedEmployee.id === employee.id) {\n        return true;\n      }\n    }\n    return false;\n    //return this.pinnedEmployees.has(employee);\n  }\n  ngOnDestroy() {\n    this.storage.set(this.STORAGE_KEY, this.pinnedEmployees);\n  }\n}\n"],"sourceRoot":"webpack:///"}